@file:OptIn(kotlinx.cinterop.ExperimentalForeignApi::class)

package dev.chouten.runners.relay

import kotlinx.cinterop.*
import relay.*  // Generated by cinterop from relay.def
import platform.posix.size_t

// Pointer to the currently loaded WASM module (managed by C++ code)
private var modulePtr: COpaquePointer? = null

/**
 * iOS implementation of NativeBridge using cinterop bindings.
 *
 * Calls into C functions defined in relay_c_api.h:
 * - relay_create_module(): Creates a Wasm3Module from WASM bytes
 * - relay_add(): Calls the "add" function in the loaded WASM
 * - relay_set_logger(): Sets a callback for WASM log messages
 * - relay_destroy_module(): Cleans up the module
 */
actual object NativeBridge {

    //TODO
    actual fun request(url: String, method: Int): Int {
        TODO("Not yet implemented")
    }

    actual fun callMethod(name: String): String {
        val ptr = modulePtr ?: run {
            RelayLogger.log("RelayWASM -> callMethod: no module loaded")
            return ""
        }
        val result = relay_callMethod(ptr, name)
        return result?.toKString() ?: run {
            RelayLogger.log("RelayWASM -> callMethod '$name' returned null (function lookup failed)")
            ""
        }
    }

    /**
     * Load a WASM module from raw bytes.
     * Uses usePinned to prevent GC from moving the byte array while C is reading it.
     */
    actual fun load(bytes: ByteArray) {
        // Destroy previous module if exists
        modulePtr?.let { relay_destroy_module(it) }

        // Pin the byte array in memory so C can safely read it
        bytes.usePinned { pinned ->
            modulePtr = relay_create_module(
                pinned.addressOf(0).reinterpret(),  // Convert to C pointer type
                bytes.size.convert<size_t>()         // Convert Int to size_t
            )
        }
    }

    /**
     * Call the "add" function in the loaded WASM module.
     * Returns 0 if no module is loaded.
     */
    actual fun add(a: Int, b: Int): Int {
        val ptr = modulePtr ?: return 0
        return relay_add(ptr, a, b)
    }

    /**
     * Initialize the logger callback.
     *
     * Uses staticCFunction to create a C function pointer from a Kotlin lambda.
     * When WASM calls host_log(), it triggers this callback which forwards
     * the message to Kotlin's RelayLogger.
     *
     * Note: The logger parameter is ignored on iOS - we use staticCFunction instead
     * because C can only call static functions, not Kotlin object methods directly.
     */
    actual fun initLogger(logger: Any) {
        relay_set_logger(staticCFunction { msg, len ->
            msg?.let {
                val message = it.toKString()
                RelayLogger.log(message)
            }
        })
    }
}